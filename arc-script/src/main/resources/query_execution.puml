@startuml
start
#HotPink:start query execution;
note
  pink denotes GUI activity
end note
group #4da542 Groovy {
  :parse script text;
}
if (are syntax errors present?) then (yes)
  #HotPink:display error markers;
  stop
else (no)
  group #4da542 Groovy {
    :execute Groovy script;
  }
endif

if (has script execution failed?) is (yes) then
  #HotPink:display error markers;
  stop
else (no)
endif

partition #dfd090 "Indexing instruction preprocessing" {
  note right
    Current implementation only considers the need to add
    implicit instructions, no merging and #pragma interpretation
    is performed.
  end note
  if (are query instructions missing?) then (yes)
    if (are index instructions missing?) then (yes)
      stop
    else (no)
    endif
  else (no)
    if (do index instructions cover query instruction indexing requirements?) then (yes)
    else (no)
      :create implicit index instructions;
    endif

    if (is pragma TRUST_INDEX present?) then (yes)
      :remove index instructions;
    else (no)
    endif
  endif
  :merge index instructions;
}


if (are any index instructions present?) then (yes)
  partition #a0c5f0 "Indexing" {
    if (storage implementation?) then (FS)
      fork
        :discover candidate entry URI;
      fork again
        :discover candidate entry URI;
      fork again
        :...; <<continuous>>
      fork again
        :discover candidate entry URI;
      end fork
    else (RDB)
      :issue single query for every possible candidate entry URI;
    endif
    :register/confirm candidate entries;
  }
else (no)
  :fetch all candidate entries;
endif

if (are query instructions present?) then (yes)
  partition #b2d2ff "Querying" {
    fork
      :load candidate entry;
      note
        Every time an activity is labelled as 'Load', it is performed
        massively concurrently on separate virtual threads as far as
        the core module is concerned.
        
        On <b>File System</b> storages every load operation is indeed
        performed concurrently.
        
        On <b>Relation Database</b> backed storages, every load operation
        is enqueued in a task queue, and batch loaded with a maximum
        batch size and an adapting timeout (adjusted based on queue size).
        
        Every individual <b>entry</b> is loaded at most once, and made
        available in a shared lookup-table for downstream operations such
        as later query executions and columns property discovery.
      end note
      partition #aliceblue "Execute WHERE clause" {
        while (property on referenced entry?)
          if (is referenced entry in lookup-table?) then (yes)
            :lookup entry;
          else (no)
            :load referenced entry;
          endif
        endwhile (no)
        :extract property value;
        :test value against property predicate;
        if (matches WHERE clause?) then (yes)
          :include in result set;
        else (no)
          :drop entry;
          kill
        endif
      }
    fork again
      :...; <<continuous>>
      -[dashed]->
    fork again
      :load candidate entry;
      :execute WHERE clause;
      -[dashed]->
    fork again
      :load candidate entry;
      :execute WHERE clause;
      -[dashed]->
    end fork
  }
else (no)  
  #HotPink:report completion;
  stop
endif

if (is custom column rendering requested?) then (yes)
  partition #lightblue "Column Property Discovery" {
    fork
      :examine result set entry;
      partition #aliceblue "Fetch target property value" {
        while (property on referenced entry?)
          if (is referenced entry in lookup-table?) then (yes)
            :lookup entry;
          else (no)
            :load referenced entry;
          endif
        endwhile (no)
        :extract property value;
      }
    fork again
      :...; <<continuous>>
    fork again
      :examine result set entry;
      :fetch target property value;
    fork again
      :load result set entry;
      :fetch target property value;
    end fork
  }
  :enumerate result set with chosen columns;
else (no)
  :enumerate result set URIs;
endif

#HotPink:render columns;

stop
@enduml
